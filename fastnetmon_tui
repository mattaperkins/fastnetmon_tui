#!/usr/bin/env python3
# fastnetmon_tui.py (IPv4 & IPv6) with banned IPs in red + runtime style toggle
import argparse
import curses
import errno
import locale
import os
import re
import time
from pathlib import Path
from typing import Callable, Dict, List, Optional

locale.setlocale(locale.LC_ALL, '')

SECTION_HEAD_RE = re.compile(
    r'^(Incoming|Outgoing|Internal|Other)\s+traffic\s+(\d+)\s+pps\s+(\d+)\s+mbps',
    re.I
)

IPV4_LINE_RE = re.compile(
    r'^(?P<ip>(?:\d{1,3}\.){3}\d{1,3})\s+'
    r'(?P<pps>\d+)\s+pps\s+'
    r'(?P<mbps>\d+)\s+mbps\b', re.I
)

IPV6_LINE_RE = re.compile(
    r'^(?P<ip>[0-9a-fA-F:]+)\s+'
    r'(?P<pps>\d+)\s+pps\s+'
    r'(?P<mbps>\d+)\s+mbps\b', re.I
)

V6_KEYS = [
    "cli_stats_ipv6_file_path",
    "cli_stats_file_path_ipv6",
    "cli_stats_file_path_v6",
]

class Row:
    __slots__ = ("label", "pps", "mbps", "is_total", "banned")
    def __init__(self, label: str, pps: int, mbps: int, is_total: bool=False, banned: bool=False):
        self.label = label
        self.pps = pps
        self.mbps = mbps
        self.is_total = is_total
        self.banned = banned

def parse_fastnetmon(text: str, ip_line_re: re.Pattern) -> Dict[str, List[Row]]:
    lines = [ln.rstrip() for ln in text.splitlines()]
    i = 0
    sections: Dict[str, List[Row]] = {"Incoming": [], "Outgoing": [], "Internal": [], "Other": []}

    while i < len(lines):
        m = SECTION_HEAD_RE.match(lines[i])
        if m:
            sec_name, pps_str, mbps_str = m.group(1), m.group(2), m.group(3)
            try:
                tot_pps = int(pps_str)
                tot_mbps = int(mbps_str)
            except ValueError:
                tot_pps = tot_mbps = 0
            sections[sec_name].append(Row(f"{sec_name} total", tot_pps, tot_mbps, True))
            i += 1
            while i < len(lines):
                if not lines[i].strip():
                    break
                if SECTION_HEAD_RE.match(lines[i]):
                    break
                line = lines[i]
                m2 = ip_line_re.match(line)
                if m2:
                    ip = m2.group('ip')
                    pps = int(m2.group('pps'))
                    mbps = int(m2.group('mbps'))
                    banned = "*banned*" in line.lower()
                    sections[sec_name].append(Row(ip, pps, mbps, False, banned))
                i += 1
        else:
            i += 1
    return sections

def read_file_safely(path: str) -> str:
    try:
        with open(path, 'r', encoding='utf-8', errors='replace') as f:
            return f.read()
    except OSError as e:
        if e.errno in (errno.ENOENT, errno.EACCES):
            return ""
        raise

def draw_bar(stdscr, y: int, x: int, width: int, ratio: float, style: str):
    width = max(4, width)
    ratio = max(0.0, min(1.0, ratio))
    filled = int(ratio * width)
    glyph = '█' if style == 'blocks' else '•'
    for i in range(width):
        pos_ratio = (i + 1) / width
        cpair = 3 if pos_ratio >= 0.9 else (2 if pos_ratio >= 0.7 else 1)
        ch = glyph if i < filled else ' '
        stdscr.attron(curses.color_pair(cpair))
        stdscr.addstr(y, x + i, ch)
        stdscr.attroff(curses.color_pair(cpair))

def guess_v6_path_from_v4(v4_path: Optional[str]) -> Optional[str]:
    if not v4_path:
        return None
    p = Path(v4_path)
    candidates = []
    if p.name == "fastnetmon.dat":
        candidates.append(p.with_name("fastnetmon_ipv6.dat"))
    if p.suffix == ".dat":
        candidates.append(p.with_name(p.stem + "_ipv6.dat"))
    candidates.append(p.with_name("fastnetmon_ipv6.dat"))
    for c in candidates:
        if c.exists():
            return str(c)
    return str(candidates[0]) if candidates else None

def get_dat_file_from_conf(conf_path: str = "/etc/fastnetmon.conf",
                           ipv6: bool = False) -> Optional[str]:
    if not os.path.isfile(conf_path):
        return None
    v4_val: Optional[str] = None
    v6_val: Optional[str] = None
    try:
        with open(conf_path, "r", encoding="utf-8", errors="ignore") as f:
            for raw in f:
                line = raw.strip()
                if not line or line.startswith("#") or "=" not in line:
                    continue
                k, v = map(str.strip, line.split("=", 1))
                if k == "cli_stats_file_path" and v and not v4_val:
                    v4_val = v
                if k in V6_KEYS and v and not v6_val:
                    v6_val = v
    except Exception:
        return None
    if ipv6:
        return v6_val or guess_v6_path_from_v4(v4_val)
    return v4_val

def run_tui(stdscr, path: str, interval: float, style: str,
            parse_fn: Callable[[str], Dict[str, List[Row]]]):
    curses.curs_set(0)
    curses.start_color()
    curses.use_default_colors()
    curses.init_pair(1, curses.COLOR_GREEN, -1)
    curses.init_pair(2, curses.COLOR_YELLOW, -1)
    curses.init_pair(3, curses.COLOR_RED, -1)      # banned IPs
    curses.init_pair(4, curses.COLOR_CYAN, -1)
    curses.init_pair(5, curses.COLOR_WHITE, -1)    # normal label
    curses.init_pair(6, curses.COLOR_MAGENTA, -1)  # section head
    curses.init_pair(7, curses.COLOR_WHITE, -1)    # totals

    stdscr.nodelay(True)

    last_mtime = 0.0
    content = ""
    autoscale = True
    max_pps = 1.0
    max_mbps = 1.0
    decay = 0.98

    current_style = style  # allow toggling at runtime

    while True:
        try:
            st = os.stat(path)
            if st.st_mtime != last_mtime:
                last_mtime = st.st_mtime
                content = read_file_safely(path)
        except FileNotFoundError:
            content = ""

        sections = parse_fn(content) if content else {"Incoming": [], "Outgoing": [], "Internal": [], "Other": []}

        cur_pps = 1
        cur_mbps = 1
        max_label_len = 0
        for rows in sections.values():
            for r in rows:
                cur_pps = max(cur_pps, r.pps)
                cur_mbps = max(cur_mbps, r.mbps)
                max_label_len = max(max_label_len, len(r.label))

        if autoscale:
            max_pps = max(cur_pps, max_pps * decay)
            max_mbps = max(cur_mbps, max_mbps * decay)
        max_pps = max(max_pps, 1.0)
        max_mbps = max(max_mbps, 1.0)

        stdscr.erase()
        h, w = stdscr.getmaxyx()

        title = f"FastNetMon TUI — watching {path}  (q=quit r=reset +/-=rate a=autoscale:{'ON' if autoscale else 'OFF'} s=style:{current_style})"
        stdscr.attron(curses.color_pair(4))
        stdscr.addstr(0, 0, title[:w-1])
        stdscr.attroff(curses.color_pair(4))

        left_label_w = max(16, min(60, max_label_len + 1))
        pps_digits = len(f"{int(max_pps):,}")
        pps_val_w = max(12, pps_digits + 4)
        gap_w = 1
        bar_span = max(10, w - left_label_w - pps_val_w - gap_w - 16)
        pps_bar_w = bar_span // 2
        mbps_bar_w = bar_span - pps_bar_w
        pps_bar_x   = left_label_w + 1
        pps_text_x  = pps_bar_x + pps_bar_w + 1
        mbps_bar_x  = pps_text_x + pps_val_w + gap_w
        mbps_text_x = mbps_bar_x + mbps_bar_w + 1

        row_y = 2
        for sec_name in ("Incoming", "Outgoing", "Internal", "Other"):
            rows = sections.get(sec_name, [])
            if row_y >= h - 3:
                break
            stdscr.attron(curses.color_pair(6))
            stdscr.addstr(row_y, 0, f"[ {sec_name} ]"[:w-1])
            stdscr.attroff(curses.color_pair(6))
            row_y += 1

            if not rows:
                stdscr.addstr(row_y, 2, "(no data)")
                row_y += 1
                continue

            for r in rows:
                if row_y >= h - 2:
                    break
                if r.is_total:
                    label_color = 7
                else:
                    label_color = 3 if r.banned else 5
                stdscr.attron(curses.color_pair(label_color))
                stdscr.addstr(row_y, 0, (r.label + " " * left_label_w)[:left_label_w])
                stdscr.attroff(curses.color_pair(label_color))

                p_ratio = r.pps / max(1.0, max_pps)
                m_ratio = r.mbps / max(1.0, max_mbps)
                draw_bar(stdscr, row_y, pps_bar_x,  pps_bar_w,  p_ratio, current_style)
                draw_bar(stdscr, row_y, mbps_bar_x, mbps_bar_w, m_ratio, current_style)
                stdscr.addstr(row_y, pps_text_x,  f"{r.pps:>10,d} pps")
                stdscr.addstr(row_y, mbps_text_x, f"{r.mbps:>8,d} mbps")
                row_y += 1

        footer = f"Scale pps:max≈{int(max_pps):,}  mbps:max≈{int(max_mbps):,}  refresh={interval:.2f}s"
        stdscr.attron(curses.color_pair(4))
        stdscr.addstr(h-1, 0, footer[:w-1])
        stdscr.attroff(curses.color_pair(4))
        stdscr.refresh()

        t_end = time.time() + interval
        while time.time() < t_end:
            ch = stdscr.getch()
            if ch == -1:
                time.sleep(0.01)
                continue
            if ch in (ord('q'), ord('Q')):
                return
            elif ch in (ord('r'), ord('R')):
                max_pps = 1.0; max_mbps = 1.0
            elif ch in (ord('a'), ord('A')):
                autoscale = not autoscale
            elif ch == ord('+'):
                interval = max(0.05, interval * 0.8)
            elif ch == ord('-'):
                interval = min(5.0, interval * 1.25)
            elif ch in (ord('s'), ord('S')):
                current_style = 'blocks' if current_style == 'dots' else 'dots'

def make_parser(ipv6: bool) -> Callable[[str], Dict[str, List[Row]]]:
    ip_re = IPV6_LINE_RE if ipv6 else IPV4_LINE_RE
    return lambda text: parse_fastnetmon(text, ip_re)

def main():
    ap = argparse.ArgumentParser(description="Unicode/curses VU-style monitor for FastNetMon summary file (IPv4/IPv6).")
    ap.add_argument('-f', '--file', default=None, help='Path to FastNetMon summary file (overrides config)')
    ap.add_argument('-c', '--config', default='/etc/fastnetmon.conf', help='Path to fastnetmon.conf (default: /etc/fastnetmon.conf)')
    ap.add_argument('-6', '--ipv6', action='store_true', help='Use IPv6 stats file and IPv6 parser')
    ap.add_argument('-i', '--interval', type=float, default=0.33, help='Refresh interval seconds (default 0.33s)')
    ap.add_argument('--style', choices=['blocks', 'dots'], default='dots',
                    help='Bar glyph style: dots (•) or blocks (█). Default: dots')
    args = ap.parse_args()

    dat_path = args.file
    if dat_path is None:
        dat_path = get_dat_file_from_conf(args.config, ipv6=args.ipv6)
        if dat_path is None:
            dat_path = "/tmp/fastnetmon_ipv6.dat" if args.ipv6 else "/tmp/fastnetmon.dat"

    parse_fn = make_parser(args.ipv6)
    curses.wrapper(run_tui, dat_path, max(0.05, args.interval), args.style, parse_fn)

if __name__ == "__main__":
    main()

